# DO NOT Filter signal:
# signal <- ecg_filter(signal = signal)
# Normalize signal
signal <- (signal - min(signal)) / (max(signal) - min(signal))
# Set indices outside of interval to 0
# signal[-random_interval] <- 0
# ann[-random_interval] <- 0
# Random interval signal/ann vectors
signal_iso <- signal[random_interval]
ann_iso <- ann[random_interval]
# Compress signal:
# Generate a random compression/dilation factor
if (round != 1) {
compression_factor <- 1 + sample(c(-1, 1), size = 1) * runif(1, min = min, max = max) # Random factor between 1 +/- (3 to 5)%
new_length <- round(length(signal_iso) * compression_factor) # Define new length for the signal based on compression/dilation factor
# Resample the ECG signal to the new length
compressed_signal <- resample(signal_iso, p = new_length, q = length(signal_iso))
# Cannot use same interpolation to do ann vector, which contains *integers* (not decimals). ie, must ensure termini of QRS, T don't become 1s or 2s if rounding
new_indices <- seq(from = 1,
to = length(ann_iso),
length.out = new_length) # Create new indices from 1 to length(ann_iso) with the new length
compressed_ann <- ann_iso[round(new_indices)] # For each new index, use the nearest original annotation
} else {
# if on the 1st round, do not dilate/compress, or add noise
compressed_signal <- signal_iso
compressed_ann <- ann_iso
new_length <- length(compressed_signal)
}
# Generate Gaussian random noise
# Compress signal:
# Generate a random compression/dilation factor
if (round != 1) {
# if on the 1st round, do not dilate/compress, or add noise
sigma <- runif(1, min = 0, max = max_noise) # vary the noise SD from 0 to max_noise parameter
noise <- rnorm(length(compressed_signal),
mean = 0,
sd = sigma) # create random noise
compressed_signal <- compressed_signal + noise # Add the noise to the original ECG signal
}
# Now, randomly place the random signal/ann interval:
# Determine a random starting point for the shifted interval
vector_length <- length(signal)
shifted_start <- sample(1:(vector_length - new_length), 1)
# Generate the new shifted indices
shifted_indices <- shifted_start:(shifted_start + new_length - 1)
# Create new vectors initialized with zeros
shifted_signal <- rep(0, vector_length)
shifted_ann <- rep(0, vector_length)
# Shift the non-zero values to the new interval
shifted_signal[shifted_indices] <- compressed_signal
shifted_ann[shifted_indices] <- compressed_ann
# Add sample to matrix
index <- sample + (round-1)*length(training_set)
training_signal[index, ] <- shifted_signal # signal
training_annotations[index, ] <- shifted_ann # ann
}
}
plot_func(training_signal[1,],training_annotations[1,])
dim(training_signal)
truth_plot <- plot_func(training_signal[1,],training_annotations[1,])
predicted_plot <- plot_func(training_signal[141,],training_annotations[141,])
subplot(truth_plot,predicted_plot,nrows = 2)
source("~/UICOM Research/annotators/code/annotator_prep_functions.R", echo=TRUE)
rounds <- 2
out <- prep_ludb(lead = lead, annotator_style = 2, rounds = 1)
#         1: 1 0 0 0 1 0 0 0 2 0 0 2 ...
#         2: 1 1 1 1 1 0 0 0 2 2 2 2 ...
#         3: 1 2 2 2 3 0 0 0 4 5 5 6 ...
source('annotator_prep_functions.R')
annotator_style <- 2
lead <- 1
rounds <- 3
out <- prep_ludb(lead = lead, annotator_style = 2, rounds = 1)
#         1: 1 0 0 0 1 0 0 0 2 0 0 2 ...
#         2: 1 1 1 1 1 0 0 0 2 2 2 2 ...
#         3: 1 2 2 2 3 0 0 0 4 5 5 6 ...
truth_plot <- plot_func(training_signal[1,],training_annotations[1,])
predicted_plot <- plot_func(training_signal[141,],training_annotations[141,])
predicted_plot2 <- plot_func(training_signal[141,],training_annotations[281,])
truth_plot <- plot_func(out$training_signal[1,],out$training_annotations[1,])
predicted_plot <- plot_func(out$training_signal[141,],out$training_annotations[141,])
nrow(out$training_signal)
annotator_style <- 2
lead <- 1
rounds <- 3
out <- prep_ludb(lead = lead, annotator_style = 2, rounds = rounds)
#         1: 1 0 0 0 1 0 0 0 2 0 0 2 ...
#         2: 1 1 1 1 1 0 0 0 2 2 2 2 ...
#         3: 1 2 2 2 3 0 0 0 4 5 5 6 ...
training_signal <- out$training_signal
training_annotations <- out$training_annotations
testing_signal <- out$testing_signal
testing_annotations <- out$testing_annotations
dim(training_signal)
truth_plot <- plot_func(out$training_signal[1,],out$training_annotations[1,])
predicted_plot <- plot_func(out$training_signal[141,],out$training_annotations[141,])
predicted_plot2 <- plot_func(out$training_signal[281,],out$training_annotations[281,])
subplot(truth_plot,predicted_plot,predicted_plot2,nrows = 3)
source('annotator_prep_functions.R')
annotator_style <- 2
lead <- 1
rounds <- 3
max_noise = 0.05
dilate_range <- c(0.03,0.05)
out <- prep_ludb(lead = lead,
annotator_style = 2,
rounds = rounds,
max_noise = max_noise
dilate_range = dilate_range)
source('annotator_prep_functions.R')
annotator_style <- 2
lead <- 1
rounds <- 3
max_noise = 0.05
dilate_range <- c(0.03,0.05)
out <- prep_ludb(lead = lead,
annotator_style = 2,
rounds = rounds,
max_noise = max_noise,
dilate_range = dilate_range)
source('annotator_prep_functions.R')
annotator_style <- 2
lead <- 1
rounds <- 3
max_noise = 0.05
dilate_range <- c(0.03,0.05)
out <- prep_ludb(lead = lead,
annotator_style = 2,
rounds = rounds,
max_noise = max_noise,
dilate_range = dilate_range)
library(stats)
source('annotator_prep_functions.R')
annotator_style <- 2
lead <- 1
rounds <- 3
max_noise = 0.05
dilate_range <- c(0.03,0.05)
out <- prep_ludb(lead = lead,
annotator_style = 2,
rounds = rounds,
max_noise = max_noise,
dilate_range = dilate_range)
#         1: 1 0 0 0 1 0 0 0 2 0 0 2 ...
#         2: 1 1 1 1 1 0 0 0 2 2 2 2 ...
#         3: 1 2 2 2 3 0 0 0 4 5 5 6 ...
training_signal <- out$training_signal
training_annotations <- out$training_annotations
testing_signal <- out$testing_signal
testing_annotations <- out$testing_annotations
help(package='stats')
install.packages('stats')
rm(list=ls())
source('annotator_prep_functions.R')
annotator_style <- 2
lead <- 1
rounds <- 3
max_noise = 0.05
dilate_range <- c(0.03,0.05)
out <- prep_ludb(lead = lead,
annotator_style = 2,
rounds = rounds,
max_noise = max_noise,
dilate_range = dilate_range)
#         1: 1 0 0 0 1 0 0 0 2 0 0 2 ...
#         2: 1 1 1 1 1 0 0 0 2 2 2 2 ...
#         3: 1 2 2 2 3 0 0 0 4 5 5 6 ...
dilate_range[1]
runif(1, min = dilate_range[1], max = dilate_range[2])
#' @descrption Input: custom list of LUDB annotations and signal. Splits into training/testing.
#' Takes random continuous segment between 2 and 8 seconds, zeros the rest. Randomly shifts the segment across the vector
#' Then normalizes the signal for each sample.
#'
#' @param dilate_range For training set: 2 element vector. Defines the range the samples will be randomly
#'
#' @param max_noise For training set: maximum standard deviation of the added Gaussian noise. ECGs are scaled from 0 to 1.
#'
#' @param rounds number of times the training dataset will be duplicated. Note: a value of 2 will double the length of the training set. A value of 1 will not change the length
prep_ludb <- function(lead,
annotator_style = 2,
split = 0.7,
dilate_range = c(0.03,0.05),
max_noise = 0.05,
rounds = 1) {
library(stats)
# Load LUDB set
load('../ludb_set.RData')
# Assign the annotation style for ML input:
use_func <- paste0('ann_wfdb2continuous', annotator_style)
#         ann_wfdb2continuous1: 1 0 0 0 1 0 0 0 2 0 0 2 ...
#         ann_wfdb2continuous2: 1 1 1 1 1 0 0 0 2 2 2 2 ...
#         ann_wfdb2continuous3: 1 2 2 2 3 0 0 0 4 5 5 6 ...
# Split into train/test
split <- 0.7 # % of samples going to training set
leads <- c("i","ii","iii","avr","avl","avf","v1","v2","v3","v4","v5","v6")
length <- 5000
sampling_frequency <- 500
annotation_function <- get(use_func) # Get the function object
# Split sets:
samples <- length(ludb_set)
sample_size <- ceiling(split * samples)
training_samples <- sample(samples, sample_size)
testing_samples <- 1:samples
testing_samples <- testing_samples[-training_samples]
training_set <- ludb_set[c(training_samples)]
testing_set <- ludb_set[c(testing_samples)]
training_signal      <- array(NA, c(length(training_set)*rounds, length))
training_annotations <- array(NA, c(length(training_set)*rounds, length))
testing_signal       <- array(NA, c(length(testing_set), length))
testing_annotations  <- array(NA, c(length(testing_set), length))
# Prep for calculating indices for time range between 2 and 8 seconds in training set
start_index <- 2 * sampling_frequency + 1
end_index <- 8 * sampling_frequency
interval_length <- 4 * sampling_frequency
# Training Set
for (round in 1:rounds) {
for (sample in 1:length(training_set)) {
# **Take a random 4 second interval of signal**:
# Randomly select the starting point for the 4 second interval
random_start <- sample(start_index:(end_index - interval_length), 1)
# Define the 4-second interval
random_interval <- random_start:(random_start + interval_length - 1)
signal <- training_set[[sample]]$signal[[leads[lead]]]
ann <- annotation_function(training_set[[sample]]$annotation[[leads[lead]]])
# DO NOT Filter signal:
# signal <- ecg_filter(signal = signal)
# Normalize signal
signal <- (signal - min(signal)) / (max(signal) - min(signal))
# Set indices outside of interval to 0
# signal[-random_interval] <- 0
# ann[-random_interval] <- 0
# Random interval signal/ann vectors
signal_iso <- signal[random_interval]
ann_iso <- ann[random_interval]
# Compress signal:
# Generate a random compression/dilation factor
if (round != 1) {
compression_factor <- 1 + sample(c(-1, 1), size = 1) * runif(1, min = dilate_range[1], max = dilate_range[2]) # Random factor between 1 +/- (3 to 5)%
new_length <- round(length(signal_iso) * compression_factor) # Define new length for the signal based on compression/dilation factor
# Resample the ECG signal to the new length
compressed_signal <- resample(signal_iso, p = new_length, q = length(signal_iso))
# Cannot use same interpolation to do ann vector, which contains *integers* (not decimals). ie, must ensure termini of QRS, T don't become 1s or 2s if rounding
new_indices <- seq(from = 1,
to = length(ann_iso),
length.out = new_length) # Create new indices from 1 to length(ann_iso) with the new length
compressed_ann <- ann_iso[round(new_indices)] # For each new index, use the nearest original annotation
} else {
# if on the 1st round, do not dilate/compress, or add noise
compressed_signal <- signal_iso
compressed_ann <- ann_iso
new_length <- length(compressed_signal)
}
# Generate Gaussian random noise
# Compress signal:
# Generate a random compression/dilation factor
if (round != 1) {
# if on the 1st round, do not dilate/compress, or add noise
sigma <- runif(1, min = 0, max = max_noise) # vary the noise SD from 0 to max_noise parameter
noise <- rnorm(length(compressed_signal),
mean = 0,
sd = sigma) # create random noise
compressed_signal <- compressed_signal + noise # Add the noise to the original ECG signal
}
# Now, randomly place the random signal/ann interval:
# Determine a random starting point for the shifted interval
vector_length <- length(signal)
shifted_start <- sample(1:(vector_length - new_length), 1)
# Generate the new shifted indices
shifted_indices <- shifted_start:(shifted_start + new_length - 1)
# Create new vectors initialized with zeros
shifted_signal <- rep(0, vector_length)
shifted_ann <- rep(0, vector_length)
# Shift the non-zero values to the new interval
shifted_signal[shifted_indices] <- compressed_signal
shifted_ann[shifted_indices] <- compressed_ann
# Add sample to matrix
index <- sample + (round-1)*length(training_set)
training_signal[index, ] <- shifted_signal # signal
training_annotations[index, ] <- shifted_ann # ann
}
}
# Testing Set (no need to select a random interval)
for (sample in 1:length(testing_set)) {
signal <- testing_set[[sample]]$signal[[leads[lead]]]
ann <- annotation_function(testing_set[[sample]]$annotation[[leads[lead]]])
# Filter signal:
signal <- ecg_filter(signal = signal)
# Normalize signal
(signal - min(signal)) / (max(signal) - min(signal))
# Set values of first and last 1000 indices to 0 (could also do 1st and last annotated indices)
signal[c(1:1000, 4001:5000)] <- 0
ann[c(1:1000, 4001:5000)] <- 0
# Add sample to matrix
testing_signal[sample, ] <- signal
testing_annotations[sample, ] <- ann
}
# Prepare output
output <- list(
training_signal = training_signal,
training_annotations = training_annotations,
testing_signal = testing_signal,
testing_annotations = testing_annotations,
training_samples = training_samples,
testing_samples = testing_samples
)
return(output)
}
source('annotator_prep_functions.R')
annotator_style <- 2
lead <- 1
rounds <- 3
max_noise = 0.05
dilate_range <- c(0.03,0.05)
out <- prep_ludb(lead = lead,
annotator_style = 2,
rounds = rounds,
max_noise = max_noise,
dilate_range = dilate_range)
#         1: 1 0 0 0 1 0 0 0 2 0 0 2 ...
#         2: 1 1 1 1 1 0 0 0 2 2 2 2 ...
#         3: 1 2 2 2 3 0 0 0 4 5 5 6 ...
source('annotator_prep_functions.R')
annotator_style <- 2
lead <- 1
rounds <- 3
max_noise = 0.05
dilate_range <- c(0.03,0.05)
out <- prep_ludb(lead = lead,
annotator_style = 2,
rounds = rounds,
max_noise = max_noise,
dilate_range = dilate_range)
#         1: 1 0 0 0 1 0 0 0 2 0 0 2 ...
#         2: 1 1 1 1 1 0 0 0 2 2 2 2 ...
#         3: 1 2 2 2 3 0 0 0 4 5 5 6 ...
training_signal <- out$training_signal
training_annotations <- out$training_annotations
testing_signal <- out$testing_signal
testing_annotations <- out$testing_annotations
logFile <- '../models/model_log.RData'
load(logFile)
new_row <- data.frame(
name = model_name,
type = model_type,
ann_style = annotator_style,
lead = lead,
bilstm_layers = bilstm_layers,
dropout = NA,
filters = NA,
epochs = epochs,
time = round(time_spent, 2),
training_samples = I(list(out$training_samples)),
confusion = I(list(confusion)),
dilate_range = dilate_range,
max_noise = max_noise,
rounds = rounds
)
model_type <- 'bilstm'
date_time <- format(Sys.time(), "%Y%m%d_%H%M%S")
model_name <- paste0(model_type,'_',date_time)
new_row <- data.frame(
name = model_name,
type = model_type,
ann_style = annotator_style,
lead = lead,
bilstm_layers = bilstm_layers,
dropout = NA,
filters = NA,
epochs = epochs,
time = round(time_spent, 2),
training_samples = I(list(out$training_samples)),
confusion = I(list(confusion)),
dilate_range = dilate_range,
max_noise = max_noise,
rounds = rounds
)
bilstm_layers <- 200 # original: 200
activation <- 'softmax' #'sigmoid': old version
mask_value <- 0
model_type <- 'bilstm'
new_row <- data.frame(
name = model_name,
type = model_type,
ann_style = annotator_style,
lead = lead,
bilstm_layers = bilstm_layers,
dropout = NA,
filters = NA,
epochs = epochs,
time = round(time_spent, 2),
training_samples = I(list(out$training_samples)),
confusion = I(list(confusion)),
dilate_range = dilate_range,
max_noise = max_noise,
rounds = rounds
)
epochs <- 20
new_row <- data.frame(
name = model_name,
type = model_type,
ann_style = annotator_style,
lead = lead,
bilstm_layers = bilstm_layers,
dropout = NA,
filters = NA,
epochs = epochs,
time = round(time_spent, 2),
training_samples = I(list(out$training_samples)),
confusion = I(list(confusion)),
dilate_range = dilate_range,
max_noise = max_noise,
rounds = rounds
)
start <- Sys.time()
end <- Sys.time()
time_spent <- end-start
new_row <- data.frame(
name = model_name,
type = model_type,
ann_style = annotator_style,
lead = lead,
bilstm_layers = bilstm_layers,
dropout = NA,
filters = NA,
epochs = epochs,
time = round(time_spent, 2),
training_samples = I(list(out$training_samples)),
confusion = I(list(confusion)),
dilate_range = dilate_range,
max_noise = max_noise,
rounds = rounds
)
confusion <- 1
new_row <- data.frame(
name = model_name,
type = model_type,
ann_style = annotator_style,
lead = lead,
bilstm_layers = bilstm_layers,
dropout = NA,
filters = NA,
epochs = epochs,
time = round(time_spent, 2),
training_samples = I(list(out$training_samples)),
confusion = I(list(confusion)),
dilate_range = dilate_range,
max_noise = max_noise,
rounds = rounds
)
I(list(confusion))
new_row <- data.frame(
name = model_name,
type = model_type,
ann_style = annotator_style,
lead = lead,
bilstm_layers = bilstm_layers,
dropout = NA,
filters = NA,
epochs = epochs,
time = round(time_spent, 2),
training_samples = I(list(out$training_samples)),
confusion = I(list(confusion)),
dilate_range = list(dilate_range),
max_noise = max_noise,
rounds = rounds
)
max_noise
model_name
model_type
annotator_style
lead
bilstm_layers
epochs
round(time_spent, 2)
I(list(out$training_samples))
I(list(confusion))
dilate_range
max_noise
rounds
new_row <- data.frame(
name = model_name,
type = model_type,
ann_style = annotator_style,
lead = lead,
bilstm_layers = bilstm_layers,
dropout = NA,
filters = NA,
epochs = epochs,
time = round(time_spent, 2),
training_samples = I(list(out$training_samples)),
confusion = I(list(confusion)),
dilate_range = dilate_range,
max_noise = max_noise,
rounds = rounds
)
new_row <- data.frame(
name = model_name,
type = model_type,
ann_style = annotator_style,
lead = lead,
bilstm_layers = bilstm_layers,
dropout = NA,
filters = NA,
epochs = epochs,
time = round(time_spent, 2),
training_samples = I(list(out$training_samples)),
confusion = I(list(confusion)),
dilate_range = I(list(dilate_range)),
max_noise = max_noise,
rounds = rounds
)
new_row
